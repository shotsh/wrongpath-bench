# wrongpath-bench trace surgery SPEC

## 0. 対象リポジトリとファイル配置

- 対象リポジトリ: https://github.com/shotsh/wrongpath-bench
- この SPEC は、`wrongpath-bench/docs/wpsurgery_spec.md` として置く想定
- ツール類は `wrongpath-bench/tools/` 以下に置く想定

---

## 1. このプロジェクトでやりたいこと

`wrongpath-bench` で作ったマイクロベンチマークに対して、ChampSim 標準の Pin トレーサで生成した **バイナリ形式トレース**をいじるツールを作る。

最初の目的は、以下の 3 段階をきちんとこなせるようになること。

1. バイナリトレースを「正しく読めている」ことを確認する  
2. 配列 B へのメモリアクセスが、トレース中のどこに出てくるかを特定できるようにする  
3. 狙った範囲のトレース（今回は B へのアクセス列）を、別の位置に「移動させる」  
   （まずは「間に挿入」ではなく、単純な **上書きコピー** でよい）

いきなり難しいことはやらず、

- 「読む」フェーズと
- 「書き換える」フェーズ

を分けて、段階的に進める。

言語は、Sho が慣れている **C と Python をメインターゲット**とする。  
（内部実装で C++ を使うのはアリだが、必須ではない）

---

## 2. 対象と前提

- 対象トレース
  - ChampSim リポジトリの `tracer/pin` 以下にある標準トレーサで生成したもの
  - フォーマットは `inc/trace_instruction.h` の `struct input_instr` と同じバイナリレイアウト
  - 1 レコードは固定長（`sizeof(input_instr)` バイト）

- 圧縮について
  - ディスク上では `*.xz` で圧縮しておいて良い
  - **編集や解析をするときは、いったん `xz -d` などで解凍して `*.trace` を扱う**
  - ChampSim 本体は `*.xz` も読めるが、trace surgery ツールは **生バイナリ (`*.trace`) を前提**とする

- マイクロベンチ
  - 当面は `wp_bench_tuned.c` のみを対象にする
  - ベンチマーク側で  
    `printf("A=%p B=%p\n", (void*)A, (void*)B);`  
    のように出力しておき、  
    **B のベースアドレスとサイズ（`ARRAY_B_SIZE`）を外から教える前提**とする

---

## 3. フェーズ別の仕様

### 3.1 フェーズ1: トレースを読めていることの確認

**目的**  
バイナリトレースが本当に `input_instr` の配列として読めているかを、自分の目で確認できるようにする。

**このフェーズのゴール**

- `trace_inspect` の出力を目視して  
  「A のアクセス」「B のアクセス」がそれっぽいアドレスに見えていると自信を持てること。

**ツール案**  
`tools/trace_inspect.py` または `tools/trace_inspect.c`

#### 入力

- `--trace PATH`  
  解凍済みのバイナリトレースファイルへのパス

- オプション
  - `--max N`  
    先頭から何レコード分を表示するか（デフォルト 100）

#### 出力（テキスト）

標準出力に、1 レコード 1 行程度で人間が読める形のダンプを出す。

例イメージ（実際のフォーマットは実装に任せるが、こんな情報は欲しい）:

- レコード番号（0 始まり）
- `ip`
- `source_memory[]` / `destination_memory[]` のうち、ゼロでないものだけ列挙

例:

```text
idx=12345 ip=0x400abc src_mem=[0x7f2000001000] dst_mem=[]
idx=12346 ip=0x400ac0 src_mem=[0x7f2000001008] dst_mem=[]
...
````

#### 実装上のポイント

* ファイルを開いて、`sizeof(input_instr)` バイトずつ順に読み取る
* C なら
  `struct input_instr rec; fread(&rec, sizeof(rec), 1, fp);`
* Python なら `struct` モジュールを使って固定長レコードとして読む
* ここでは「全フィールドを完璧に表示する」ことは目的ではなく、
  **メモリアクセスのアドレスがそれっぽく見えていることを確認できれば OK**

---

### 3.2 フェーズ2: 配列 B へのアクセス位置の特定

**目的**
「配列 B へのロードがトレースのどこに現れているか」をテキストで一覧できるようにする。

**このフェーズのゴール**

* `find_b_accesses` の出力から

  * B へのアクセスが「この辺りのレコードに固まっている」
  * outer ループごとに連続したチャンクになっていそう
    という感覚を掴めること。

**ツール案**
`tools/find_b_accesses.py` など

#### 入力

* `--trace PATH`
  解凍済みのバイナリトレース

* `--b-base 0x...`
  ベンチマーク実行時に `printf("B=%p\n")` で得たポインタ値をそのまま 16 進リテラルとして渡す

* `--b-size N`
  `ARRAY_B_SIZE * sizeof(double)` など、B のバイトサイズ
  （面倒なら `ARRAY_B_SIZE` と「double 配列前提」を決め打ちでもよい）

* オプション

  * `--max-hits N`
    見つける B アクセスの最大件数（デフォルトは制限無しか、例えば 1e6）

#### 判定条件

* 1 レコード中の `source_memory[]` または `destination_memory[]` に含まれるアドレス `addr` について、

  * `b_base <= addr < b_base + b_size` なら「B へのアクセス」とみなす

#### 出力（テキストまたは CSV）

最低限、次の情報を 1 行ずつ出す:

* レコード番号 `idx`
* アクセスアドレス `addr`
* 読みか書きか（source か destination か）
* `ip`（あると便利）

例:

```text
idx,kind,ip,addr
123450,load,0x400c00,0x7f2200000000
123451,load,0x400c00,0x7f2200000008
...
```

この段階でやりたいのは、

* 「B のアクセスが、この辺りのレコード番号に固まっている」
* 「連続した 1024 要素のチャンクが outer ループごとに出ている」

などを目視で把握すること。

---

### 3.3 フェーズ3: トレース書き換え（簡易版、上書き）

**目的**
「B にアクセスしている連続したチャンク」を、トレース中の別の位置にコピーして上書きし、
最終的に ChampSim に食わせるための「改造トレース」を作る。

ここではまず「間に挿入」ではなく、**「上書きコピー」で済ませる簡易版**をゴールにする。

**このフェーズのゴール**

* 指定した `[src_begin, src_end)` のレコード列が
  `[dst_begin, dst_begin + (src_end - src_begin))` に
  期待通りコピーされていることを、`trace_inspect` の出力などで確認できること。

**初回の想定シナリオ**

* まずは

  * 「1 個の outer iteration に対応する B チャンク」をコピー元に選び
  * 「別の outer iteration の近く」を書き換え先に選ぶ
* これで

  * 「あるループ反復の途中に、他の反復の B アクセスをまるごと持ってくる」
    という形を試す

**ツール案**
`tools/trace_overwrite_range.py` または C 版

#### 入力

* `--in PATH_IN`
  元のバイナリトレース

* `--out PATH_OUT`
  書き換え後のバイナリトレース

* コピー元範囲

  * `--src-begin I`
    コピー元レコードの開始インデックス（0 始まり、含む）
  * `--src-end J`
    コピー元レコードの終了インデックス（含まない）

* 書き換え先

  * `--dst-begin K`
    上書きコピーを開始する先頭インデックス
    （`K + (J - I) <= 総レコード数` になるように呼び出し側で保証する）

#### 挙動

* 元トレースを先頭から順に読みながら、

  * レコード番号 `idx` が `[dst_begin, dst_begin + (src_end - src_begin))` の範囲にあるときは、

    * `src_begin` から順に読んだレコードを出力する
  * それ以外の範囲は、元のレコードをそのまま出力する

イメージ:

* 元トレース:
  `... [A][B][C][D][E][F][G][H] ...`
* `src_begin=20, src_end=24` → `[C][D][E][F]` をコピー
* `dst_begin=100` とすると、100〜103 番を `[C][D][E][F]` に上書き

この段階では、

* ブランチ方向やレジスタ値などは **そのままコピー**
* トレース全体の長さも変えない

という制約で十分とする。

---

## 4. 将来的な方向性メモ（まだやらなくて良いが、意識だけしておく）

この SPEC はあくまで「ステップ1〜3」をやるための最小バージョン。
今後余裕が出てきたら、次のような発展をしていくことを想定する。

1. **「上書き」ではなく「挿入」モードの実装**

   * src 範囲をコピーして、dst 位置に挿入し、残りを後ろに押し出す
   * ChampSim が扱う命令数が増えるので、`-t` で trace の終わりを制御するなど工夫が必要

2. **ループ検出の自動化**

   * 今は「マイクロベンチを知っている人間」が B チャンクを指定する前提
   * 将来的には、

     * IP の繰り返しパターンや
     * アドレスストライドの規則性
       を見てループ本体と tail を自動同定する方向もあり得る

3. **ChampSim ランとの統合**

   * 改造前後のトレースを自動で

     * 解凍
     * ChampSim で実行
     * IPC/MPKI 等を集計
   * という一連のスクリプトを `scripts/` 以下にまとめる

4. **マイクロアーキテクチャとの橋渡し**

   * trace surgery の結果を見て

     * 「このくらい tail を先読みできるとこれだけ効く」
       という目安を作り、
   * 本物の wrong-path 実装や scheduler 実装を設計するときの指針にする

当面は、上の 1〜3 は「将来の TODO」として頭の片隅に置いておくだけで良い。
まずはこの SPEC に書いた **フェーズ1〜3を、C と Pythonで自力で触れるレベルに落とすこと**を最優先とする。
